Unity Editor version:    2021.3.36f1 (7a0645017be0)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.15.7 (Build 19H2026)
Darwin version:          19.6.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker0
-projectPath
/Users/administrator/Desktop/Unity Projects/FightingGame
-logFile
Logs/AssetImportWorker0.log
-srvPort
49611
Successfully changed project path to: /Users/administrator/Desktop/Unity Projects/FightingGame
/Users/administrator/Desktop/Unity Projects/FightingGame
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Player connection [4561812928] Host "[IP] 192.168.0.104 [Port] 0 [Flags] 2 [Guid] 3016885398 [EditorId] 3016885398 [Version] 1048832 [Id] OSXEditor(0,MacBook-Pro-2.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined multi-casting on [225.0.0.222:54997]...

Player connection [4561812928] Host "[IP] 192.168.0.104 [Port] 0 [Flags] 2 [Guid] 3016885398 [EditorId] 3016885398 [Version] 1048832 [Id] OSXEditor(0,MacBook-Pro-2.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined alternative multi-casting on [225.0.0.222:34997]...

[Physics::Module] Initialized MultithreadedJobDispatcher with {0} workers.
Refreshing native plugins compatible for Editor in 179.69 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.36f1 (7a0645017be0)
[Subsystems] Discovering subsystems at path /Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/administrator/Desktop/Unity Projects/FightingGame/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel HD Graphics 4000 (low power)
Metal devices available: 1
0: Intel HD Graphics 4000 (low power)
Using device Intel HD Graphics 4000 (low power)
Initializing Metal device caps: Intel HD Graphics 4000
Initialize mono
Mono path[0] = '/Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56092
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.006144 seconds.
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 157.56 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.501 seconds
Domain Reload Profiling:
	ReloadAssembly (2502ms)
		BeginReloadAssembly (296ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (1ms)
		EndReloadAssembly (1751ms)
			LoadAssemblies (297ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (357ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (65ms)
			SetupLoadedEditorAssemblies (1206ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (14ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (158ms)
				BeforeProcessingInitializeOnLoad (2ms)
				ProcessInitializeOnLoadAttributes (871ms)
				ProcessInitializeOnLoadMethodAttributes (160ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.013082 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.31 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Package Manager log level set to [2]
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  3.017 seconds
Domain Reload Profiling:
	ReloadAssembly (3020ms)
		BeginReloadAssembly (320ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (60ms)
		EndReloadAssembly (2447ms)
			LoadAssemblies (338ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (790ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (147ms)
			SetupLoadedEditorAssemblies (1141ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (141ms)
				ProcessInitializeOnLoadAttributes (924ms)
				ProcessInitializeOnLoadMethodAttributes (59ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Hub/Editor/2019.4.3f1/2021.3.36f1/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.02 seconds
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.24 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3683 Unused Serialized files (Serialized files now loaded: 0)
Unloading 40 unused Assets / (1.7 MB). Loaded Objects now: 4134.
Memory consumption went from 153.6 MB to 151.9 MB.
Total: 8.023387 ms (FindLiveObjects: 0.514348 ms CreateObjectMapping: 0.521738 ms MarkObjects: 6.014453 ms  DeleteObjects: 0.970551 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 1101.232461 seconds.
  path: Assets/Scripts/AudioManager.cs
  artifactKey: Guid(6f36f4b6c6f6e4f3383a174c81386945) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Number of updated assets reloaded before import = 0
Start importing Assets/Scripts/AudioManager.cs using Guid(6f36f4b6c6f6e4f3383a174c81386945) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '954f4d54c4d80a96f5c7dca30eabb89b') in 0.898724 seconds 
Number of asset objects unloaded after import = 0
========================================================================
Received Import Request.
  Time since last request: 0.000133 seconds.
  path: Assets/Scripts/CameraBehavior.cs
  artifactKey: Guid(2c4658aba942246dd841a4ee4df998fa) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Number of updated assets reloaded before import = 0
Start importing Assets/Scripts/CameraBehavior.cs using Guid(2c4658aba942246dd841a4ee4df998fa) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ec5470b8c7df68a60bbc06fd860285dd') in 0.002951 seconds 
Number of asset objects unloaded after import = 0
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003952 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 7.54 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.264 seconds
Domain Reload Profiling:
	ReloadAssembly (6266ms)
		BeginReloadAssembly (495ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (12ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (235ms)
		EndReloadAssembly (5245ms)
			LoadAssemblies (298ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1207ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (277ms)
			SetupLoadedEditorAssemblies (3154ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (6ms)
				RefreshPlugins (8ms)
				BeforeProcessingInitializeOnLoad (307ms)
				ProcessInitializeOnLoadAttributes (2674ms)
				ProcessInitializeOnLoadMethodAttributes (128ms)
				AfterProcessingInitializeOnLoad (11ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (17ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.03 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4137.
Memory consumption went from 146.6 MB to 145.0 MB.
Total: 13.298544 ms (FindLiveObjects: 1.650475 ms CreateObjectMapping: 1.460219 ms MarkObjects: 8.134700 ms  DeleteObjects: 2.050169 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 573.910875 seconds.
  path: Assets/Scripts/CameraFocalPoint.cs
  artifactKey: Guid(7f1879c53fda841489d188b3ba0d1e4c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Number of updated assets reloaded before import = 0
Start importing Assets/Scripts/CameraFocalPoint.cs using Guid(7f1879c53fda841489d188b3ba0d1e4c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'c3b241d97c90b1b20b24da64c2295142') in 0.012081 seconds 
Number of asset objects unloaded after import = 0
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.009293 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.25 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  3.723 seconds
Domain Reload Profiling:
	ReloadAssembly (3725ms)
		BeginReloadAssembly (669ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (28ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (230ms)
		EndReloadAssembly (2810ms)
			LoadAssemblies (452ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (896ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (151ms)
			SetupLoadedEditorAssemblies (1365ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (115ms)
				ProcessInitializeOnLoadAttributes (1183ms)
				ProcessInitializeOnLoadMethodAttributes (50ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.05 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.7 MB). Loaded Objects now: 4140.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 5.821974 ms (FindLiveObjects: 0.432085 ms CreateObjectMapping: 0.180906 ms MarkObjects: 4.320965 ms  DeleteObjects: 0.885826 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005305 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 2.50 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.587 seconds
Domain Reload Profiling:
	ReloadAssembly (6589ms)
		BeginReloadAssembly (462ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (179ms)
		EndReloadAssembly (5667ms)
			LoadAssemblies (326ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (910ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (448ms)
			SetupLoadedEditorAssemblies (3472ms)
				LogAssemblyErrors (1ms)
				InitializePlatformSupportModulesInManaged (23ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (3ms)
				BeforeProcessingInitializeOnLoad (322ms)
				ProcessInitializeOnLoadAttributes (2953ms)
				ProcessInitializeOnLoadMethodAttributes (160ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (42ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.10 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4143.
Memory consumption went from 146.6 MB to 145.0 MB.
Total: 12.996361 ms (FindLiveObjects: 0.616935 ms CreateObjectMapping: 1.512242 ms MarkObjects: 9.486581 ms  DeleteObjects: 1.377672 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005288 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.47 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.223 seconds
Domain Reload Profiling:
	ReloadAssembly (6225ms)
		BeginReloadAssembly (1785ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (34ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (590ms)
		EndReloadAssembly (3488ms)
			LoadAssemblies (1046ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1315ms)
			ReleaseScriptCaches (9ms)
			RebuildScriptCaches (279ms)
			SetupLoadedEditorAssemblies (1510ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (15ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (181ms)
				ProcessInitializeOnLoadAttributes (1258ms)
				ProcessInitializeOnLoadMethodAttributes (47ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 7.69 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4146.
Memory consumption went from 146.6 MB to 145.0 MB.
Total: 11.903632 ms (FindLiveObjects: 0.878120 ms CreateObjectMapping: 0.645342 ms MarkObjects: 9.577820 ms  DeleteObjects: 0.799968 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003977 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.30 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.331 seconds
Domain Reload Profiling:
	ReloadAssembly (6335ms)
		BeginReloadAssembly (334ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (135ms)
		EndReloadAssembly (5670ms)
			LoadAssemblies (252ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1374ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (243ms)
			SetupLoadedEditorAssemblies (3419ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (266ms)
				ProcessInitializeOnLoadAttributes (2971ms)
				ProcessInitializeOnLoadMethodAttributes (155ms)
				AfterProcessingInitializeOnLoad (9ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (35ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 7.12 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4149.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 9.022544 ms (FindLiveObjects: 0.421888 ms CreateObjectMapping: 0.240022 ms MarkObjects: 6.480161 ms  DeleteObjects: 1.877508 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004071 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.06 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  3.174 seconds
Domain Reload Profiling:
	ReloadAssembly (3176ms)
		BeginReloadAssembly (413ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (15ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (115ms)
		EndReloadAssembly (2478ms)
			LoadAssemblies (328ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (739ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (104ms)
			SetupLoadedEditorAssemblies (1320ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (8ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (94ms)
				ProcessInitializeOnLoadAttributes (1158ms)
				ProcessInitializeOnLoadMethodAttributes (53ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.06 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.7 MB). Loaded Objects now: 4152.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 6.360966 ms (FindLiveObjects: 0.449993 ms CreateObjectMapping: 0.516261 ms MarkObjects: 4.526526 ms  DeleteObjects: 0.865981 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003992 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 2.80 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  5.298 seconds
Domain Reload Profiling:
	ReloadAssembly (5302ms)
		BeginReloadAssembly (307ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (116ms)
		EndReloadAssembly (4728ms)
			LoadAssemblies (205ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1216ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (345ms)
			SetupLoadedEditorAssemblies (2548ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (25ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (3ms)
				BeforeProcessingInitializeOnLoad (250ms)
				ProcessInitializeOnLoadAttributes (2116ms)
				ProcessInitializeOnLoadMethodAttributes (139ms)
				AfterProcessingInitializeOnLoad (10ms)
				EditorAssembliesLoaded (3ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.70 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4155.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 31.938698 ms (FindLiveObjects: 5.538294 ms CreateObjectMapping: 5.553792 ms MarkObjects: 18.945601 ms  DeleteObjects: 1.893335 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005388 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.33 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  4.309 seconds
Domain Reload Profiling:
	ReloadAssembly (4311ms)
		BeginReloadAssembly (480ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (12ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (138ms)
		EndReloadAssembly (3618ms)
			LoadAssemblies (413ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1366ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (190ms)
			SetupLoadedEditorAssemblies (1633ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (359ms)
				ProcessInitializeOnLoadAttributes (1216ms)
				ProcessInitializeOnLoadMethodAttributes (44ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (10ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.06 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4158.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 5.371972 ms (FindLiveObjects: 0.419619 ms CreateObjectMapping: 0.197508 ms MarkObjects: 3.968780 ms  DeleteObjects: 0.784105 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003980 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.23 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  2.931 seconds
Domain Reload Profiling:
	ReloadAssembly (2932ms)
		BeginReloadAssembly (360ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (17ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (115ms)
		EndReloadAssembly (2302ms)
			LoadAssemblies (187ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (763ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (113ms)
			SetupLoadedEditorAssemblies (1121ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (100ms)
				ProcessInitializeOnLoadAttributes (963ms)
				ProcessInitializeOnLoadMethodAttributes (41ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (8ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.10 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.7 MB). Loaded Objects now: 4161.
Memory consumption went from 146.7 MB to 145.0 MB.
Total: 6.596098 ms (FindLiveObjects: 0.461150 ms CreateObjectMapping: 0.498680 ms MarkObjects: 4.817701 ms  DeleteObjects: 0.816022 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004145 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 3.20 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  5.710 seconds
Domain Reload Profiling:
	ReloadAssembly (5711ms)
		BeginReloadAssembly (309ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (12ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (121ms)
		EndReloadAssembly (5067ms)
			LoadAssemblies (223ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1516ms)
			ReleaseScriptCaches (6ms)
			RebuildScriptCaches (182ms)
			SetupLoadedEditorAssemblies (2527ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (18ms)
				SetLoadedEditorAssemblies (3ms)
				RefreshPlugins (3ms)
				BeforeProcessingInitializeOnLoad (176ms)
				ProcessInitializeOnLoadAttributes (2175ms)
				ProcessInitializeOnLoadMethodAttributes (136ms)
				AfterProcessingInitializeOnLoad (13ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (20ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.64 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.7 MB). Loaded Objects now: 4164.
Memory consumption went from 146.7 MB to 145.1 MB.
Total: 19.325045 ms (FindLiveObjects: 4.858495 ms CreateObjectMapping: 0.718894 ms MarkObjects: 11.942027 ms  DeleteObjects: 1.796216 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 1178.613885 seconds.
  path: Assets/Scripts/CharacterMovement.cs
  artifactKey: Guid(21e67d40690914ee7a81f162e9c30abf) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Number of updated assets reloaded before import = 0
Start importing Assets/Scripts/CharacterMovement.cs using Guid(21e67d40690914ee7a81f162e9c30abf) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'fb9c425d770ac58bf6a542e035947208') in 0.023468 seconds 
Number of asset objects unloaded after import = 0
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.007107 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.36 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  3.835 seconds
Domain Reload Profiling:
	ReloadAssembly (3840ms)
		BeginReloadAssembly (627ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (32ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (203ms)
		EndReloadAssembly (2933ms)
			LoadAssemblies (393ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (925ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (172ms)
			SetupLoadedEditorAssemblies (1392ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (105ms)
				ProcessInitializeOnLoadAttributes (1205ms)
				ProcessInitializeOnLoadMethodAttributes (56ms)
				AfterProcessingInitializeOnLoad (12ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (25ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.30 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4167.
Memory consumption went from 146.7 MB to 145.1 MB.
Total: 10.888824 ms (FindLiveObjects: 0.805369 ms CreateObjectMapping: 1.989103 ms MarkObjects: 7.241176 ms  DeleteObjects: 0.850532 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003847 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 5.71 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.233 seconds
Domain Reload Profiling:
	ReloadAssembly (6237ms)
		BeginReloadAssembly (476ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (137ms)
		EndReloadAssembly (5298ms)
			LoadAssemblies (543ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1708ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (368ms)
			SetupLoadedEditorAssemblies (2525ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (28ms)
				SetLoadedEditorAssemblies (5ms)
				RefreshPlugins (6ms)
				BeforeProcessingInitializeOnLoad (173ms)
				ProcessInitializeOnLoadAttributes (2144ms)
				ProcessInitializeOnLoadMethodAttributes (158ms)
				AfterProcessingInitializeOnLoad (10ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.11 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.7 MB). Loaded Objects now: 4170.
Memory consumption went from 146.7 MB to 145.1 MB.
Total: 7.064762 ms (FindLiveObjects: 0.669206 ms CreateObjectMapping: 0.308428 ms MarkObjects: 4.649241 ms  DeleteObjects: 1.435988 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004020 seconds.
Begin MonoManager ReloadAssembly
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.66 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
[Package Manager] Server::EnsureServerProcessIsRunning -- launch failed, reason: Unity was launched with the -noUpm command-line argument
[Package Manager] Cannot connect to Unity Package Manager local server
Mono: successfully reloaded assembly
- Completed reload, in  6.068 seconds
Domain Reload Profiling:
	ReloadAssembly (6070ms)
		BeginReloadAssembly (474ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (129ms)
		EndReloadAssembly (5171ms)
			LoadAssemblies (460ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1381ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (267ms)
			SetupLoadedEditorAssemblies (2922ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (267ms)
				ProcessInitializeOnLoadAttributes (2483ms)
				ProcessInitializeOnLoadMethodAttributes (145ms)
				AfterProcessingInitializeOnLoad (12ms)
				EditorAssembliesLoaded (3ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (33ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.66 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3574 Unused Serialized files (Serialized files now loaded: 0)
Unloading 35 unused Assets / (1.6 MB). Loaded Objects now: 4173.
Memory consumption went from 146.7 MB to 145.1 MB.
Total: 17.591530 ms (FindLiveObjects: 2.389363 ms CreateObjectMapping: 2.165952 ms MarkObjects: 11.769202 ms  DeleteObjects: 1.261524 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:CustomObjectIndexerAttribute: bc11b3a6c3213fcdd17b65e7da85e133 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:SearchIndexIgnoredProperties: e643bd26f0fe6173181afceb89e7c659 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
